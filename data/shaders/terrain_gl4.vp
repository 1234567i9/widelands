#version 130
#extension GL_ARB_uniform_buffer_object: enable

// From terrain_common_gl4:
void init_common();
uvec4 get_field_base(ivec2 coord);
float calc_brightness(uint node_ubrightness);
void calc_basepix(ivec2 coord, out vec2 basepix, out float heightpix, out uint node_brightness);
void calc_pix(ivec2 coord, out vec2 pix, out uint node_brightness);

// Per-vertex Attributes.
// X,Y: relative vertex map coordinate
// Z,W: relative triangle map coordinate
//      low bit of Z: 0 for d-triangle, 1 for r-triangle
//      bits 1&2 of Z: vertex ID for dithering
in ivec4 in_vertex_coordinate;

// Per-instance/patch Attributes.
in ivec2 in_patch_coordinate;

// Primary Constants.
uniform vec2 u_position_scale;
uniform vec2 u_position_offset;
uniform float u_z_value;

// Terrain information (secondary constants in a uniform buffer).
struct Terrain {
	vec2 offset;
	int dither_layer;
};

layout(std140) uniform block_terrains {
	Terrain u_terrains[128];
};

// Varyings: Output of vertex shader.

// X,Y: offset into texture atlas
// Z,W: texture coordinate
out vec4 var_texture;

// X,Y: offset into texture atlas
// Z,W: dither texture coordinate
out vec4 var_dither[3];

out float var_brightness;

// Constants
const float kTextureSideLength = 64;

void main() {
	init_common();

	// Compute coordinate of field that owns the triangle to which this
	// vertex belongs.
	ivec2 field_coord;
	field_coord.x = in_patch_coordinate.x + (in_vertex_coordinate.z >> 3);
	field_coord.y = in_patch_coordinate.y + in_vertex_coordinate.w;

	uvec4 field = get_field_base(field_coord);
	bool is_down = (in_vertex_coordinate.z & 1) == 0;
	uint dither_vid = uint((in_vertex_coordinate.z >> 1) & 3);
	uint terrain = is_down ? field.y : field.x;

	ivec2 node_coord = in_patch_coordinate.xy + in_vertex_coordinate.xy;
	uint node_brightness;
	float node_heightpix;
	vec2 vertex_basepix;

	calc_basepix(node_coord, vertex_basepix, node_heightpix, node_brightness);
	// On-screen position
	gl_Position.x = vertex_basepix.x;
	gl_Position.y = vertex_basepix.y - node_heightpix;
	gl_Position.xy = gl_Position.xy * u_position_scale + u_position_offset;
	gl_Position.z = u_z_value;
	gl_Position.w = 1.;

	// Brightness
	var_brightness = calc_brightness(node_brightness);

	// Texture coordinates
	vec2 vertex_texcoord;
	vertex_texcoord.x = vertex_basepix.x * (1. / kTextureSideLength);
	vertex_texcoord.y = -vertex_basepix.y * (1. / kTextureSideLength);

	// Base texture information
	var_texture.xy = u_terrains[terrain].offset;
	var_texture.zw = vertex_texcoord;

	// Dithering. Vertices are labeled by their dither_vid. Note that the VIDs
	// are different depending on whether the vertex is part of the r- or d-
	// triangle.
	//
	//       2-1---d---0
	//       / \     /
	//      r  r\d  d
	//     /     \ /
	//    0---r--1-2
	//
	// Channel 0: opposite triangle of the same field
	// Channel 1: x-major outside neighbor
	// Channel 2: y-major outside neighbor
	int dither_layer = u_terrains[terrain].dither_layer;
	{
		uint other_terrain = is_down ? field.x : field.y;

		var_dither[0].zw = vec2(0.5, 0);

		if (other_terrain != terrain) {
			int other_dither_layer = u_terrains[other_terrain].dither_layer;

			if (other_dither_layer > dither_layer) {
				var_dither[0].xy = u_terrains[other_terrain].offset;
				if (dither_vid != 0u)
					var_dither[0].zw = vec2(2u - dither_vid, 1);
			}
		}
	}
	{
		ivec2 other_coord = field_coord;
		other_coord.x += is_down ? -1 : 1;
		uvec4 other_field = get_field_base(other_coord);
		uint other_terrain = is_down ? other_field.x : other_field.y;

		var_dither[1].zw = vec2(0.5, 0);

		if (other_terrain != terrain) {
			int other_dither_layer = u_terrains[other_terrain].dither_layer;

			if (other_dither_layer > dither_layer) {
				var_dither[1].xy = u_terrains[other_terrain].offset;
				if (dither_vid != 1u)
					var_dither[1].zw = vec2(dither_vid / 2u, 1);
			}
		}
	}
	{
		ivec2 other_coord = field_coord;
		other_coord.y += is_down ? 1 : -1;
		other_coord.x += is_down ? -1 : 0;
		other_coord.x += ((field_coord.y & 1) != 0) ? 1 : 0;
		uvec4 other_field = get_field_base(other_coord);
		uint other_terrain = is_down ? other_field.x : other_field.y;

		var_dither[2].zw = vec2(0.5, 0);

		if (other_terrain != terrain) {
			int other_dither_layer = u_terrains[other_terrain].dither_layer;

			if (other_dither_layer > dither_layer) {
				var_dither[2].xy = u_terrains[other_terrain].offset;
				if (dither_vid != 2u)
					var_dither[2].zw = vec2(1u - dither_vid, 1);
			}
		}
	}
}
